# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iu2QJXSzDnpVbsYVh9HJ-IEAm6LhkbpF
"""

#importing required module
import copy
import math
import time
import heapq as hq
from queue import Queue

#getting initial state from user or generate initialstate
def getinitialstate():
    print("Enter 1 for Random grid.\nEnter 2 for user input .")
    choice = int(input("Enter your choice : "))
    lst = []
    if(choice==2):
        n = int(input("Enter order of Puzzle (blank = -1): "))
        for i in range(1, n+1):
            print("Enter row ", i, ": ", sep=" ", end=" ")
            lst.append(list(map(int, input().split())))
    else:
        lst = [[3, 2, 1],
                [4, 5, 6],
                [8, 7, -1]]

    return lst

#generate targetstate
def gettarget(n):
    k = 1
    target = []
    for i in range(n):
        temp = []
        for j in range(n):
            temp.append(k)
            k+=1
        target.append(temp)
    target[n-1][n-1] = -1
    return target

#left shift of blank
def leftstate(initialstate, x, y):
    initialstate[x][y],initialstate[x][y-1] = initialstate[x][y-1], initialstate[x][y]
    return initialstate

#right shift of blank
def rightstate(initialstate, x, y):
    initialstate[x][y], initialstate[x][y + 1] = initialstate[x][y + 1], initialstate[x][y]
    return initialstate

#up shift of blank
def upstate(initialstate, x, y):
    initialstate[x-1][y], initialstate[x][y] = initialstate[x][y], initialstate[x-1][y]
    return initialstate

#down shift of blank
def downstate(initialstate, x, y):
    initialstate[x][y], initialstate[x+1][y] = initialstate[x+1][y], initialstate[x][y]
    return initialstate

#compare search state and target state
def compare_initial_target(initialstate, targetstate):
    for i in range(len(initialstate)):
        for j in range(len(initialstate[i])):
            if initialstate[i][j] != targetstate[i][j]:
                return False
    return True

#finding position of blank
def find_position_of_blank(statelist):
    for i in range(len(statelist)):
        for j in range(len(statelist[i])):
            if statelist[i][j] == -1:
                return (i, j)
    return (2, 2)

#find mahatten distance
def find_manhatten_distance(initialstate):
    d = {1:[0,0], 2:[0,1], 3:[0,2], 4:[1,0], 5:[1,1], 6:[1,2], 7:[2.,0], 8:[2,1]}
    manhatten = 0
    for i in range(len(initialstate)):
      for j in range(len(initialstate[i])):
        if initialstate[i][j]!=-1:
          x, y = d[initialstate[i][j]]
          manhatten = manhatten + abs(x-i) + abs(y-j)
    return manhatten;
# initialstate = getinitialstate()
# find_manhatten_distance(initialstate)

#find sum  of misplaced tiles
def find_number_of_misplaced_tiles(initialstate):
    k = 1
    misplaced = 0
    for i in range(len(initialstate)):
      for j in range(len(initialstate[i])):
        if initialstate[i][j]!=-1:
          if(k!=initialstate[i][j]):
            misplaced = misplaced + 1
        k = k+1
    return misplaced

# initialstate = getinitialstate()
# find_number_of_misplaced_tiles(initialstate)

#find sum of euclidean distance of each tiles
def find_euclidean(initialstate):
    d = {1:[0,0], 2:[0,1], 3:[0,2], 4:[1,0], 5:[1,1], 6:[1,2], 7:[2.,0], 8:[2,1]}
    euclidean = 0
    for i in range(len(initialstate)):
      for j in range(len(initialstate[i])):
        if initialstate[i][j]!=-1:
          x, y = d[initialstate[i][j]]
          euclidean = euclidean + math.sqrt(abs((x-i)**2 + (y-j)**2))
    return euclidean;

def print_state(initialstate):
  for i in range(len(initialstate)):
    for j in range(len(initialstate[i])):
      print(initialstate[i][j],sep=" ",end=" ")
    print()

#puzzle solved for h(n) = 0
def heuristics_with_zero(initialstate,targetstate):
    timeLimit=40
    startTime=time.time()
    visited = {}
    queue = Queue()
    queue.put([initialstate,[]])
    lenoflist = len(initialstate)
    stepcount = 0
    while(queue.empty()==False):
        new_initialstate1 = queue.get()
        initialstate = new_initialstate1[0]
        lst = copy.deepcopy(new_initialstate1[1]) 
        if(compare_initial_target(initialstate, targetstate)):
            return [stepcount, lst, True,time.time()-startTime]
        if(time.time()-startTime>timeLimit):
            return [stepcount, lst , False,time.time()-startTime]
        k = tuple(map(tuple,initialstate))
        if k not in visited.keys():
            visited.update({k: 1})
            stepcount = stepcount + 1
            x, y = find_position_of_blank(initialstate)
            if(x<lenoflist-1):
                downlist = downstate(copy.deepcopy(initialstate), x, y)
                lst1 = copy.deepcopy(new_initialstate1[1])
                lst1.append("down")
                queue.put([downlist,lst1])
            if(x>0):
                uplist = upstate(copy.deepcopy(initialstate), x, y)
                lst2 = copy.deepcopy(new_initialstate1[1])
                lst2.append("up")
                queue.put([uplist,lst2])
            if (y > 0):
                leftlist = leftstate(copy.deepcopy(initialstate), x, y)
                lst3 = copy.deepcopy(new_initialstate1[1])
                lst3.append("left")
                queue.put([leftlist,lst3])
            if(y<lenoflist-1):
                rightlist = rightstate(copy.deepcopy(initialstate), x, y)
                lst4 = copy.deepcopy(new_initialstate1[1])
                lst4.append("right")
                queue.put([rightlist, lst4])
            
            
            

initialstate = getinitialstate()
targetstate = gettarget(len(initialstate))
print("initial state :")
print_state(initialstate)
print("target state")
print_state(targetstate)
lst1 = heuristics_with_zero(initialstate,targetstate)  
if(lst1[2]==True):
    print("Number of explored node :",lst1[0])
    print("\nDepth of search node(hight) : ",len(lst1[1]))
    print("\npath of target : ", lst1[1])
    print("Taken Time : ",round(lst1[3],2))
else:
    print("Puzzle could not be solved within given time limit.")
    print("Number of explored nodes :",lst1[0])

#puzzle solved for heuristic value with manhatten f(n) = g(n) + h(n)
#h(n) = manhatten distance
def heuristics_with_manhatten(initialstate,targetstate):
    timeLimit=40
    startTime=time.time()
    visited = {}
    queue = []
    heuristics_val = find_manhatten_distance(initialstate)
    #queue.append(g(n)+h(n), initialstate, pathlist, g(n),)
    queue.append([0+heuristics_val,initialstate,[],0,heuristics_val])
    lenoflist = len(initialstate)
    stepcount = 0
    i = 0
    while(len(queue)!=0):
        hq.heapify(queue)
        new_initialstate1 = queue.pop(0)
        initialstate = new_initialstate1[1]
        lst = copy.deepcopy(new_initialstate1[2])
        g_n = new_initialstate1[3] 
        if(compare_initial_target(initialstate, targetstate)):
            return [stepcount, lst, True,time.time()-startTime]
        if(time.time()-startTime>timeLimit):
            return [stepcount, lst , False,time.time()-startTime]
        k = tuple(map(tuple,initialstate))
        if k not in visited.keys():
            visited.update({k: 1})
            stepcount = stepcount + 1
            x, y = find_position_of_blank(initialstate)
            if(y<lenoflist-1):
                rightlist = rightstate(copy.deepcopy(initialstate), x, y)
                lst1 = copy.deepcopy(lst)
                lst1.append("right")
                h = find_manhatten_distance(rightlist) 
                new_heuristics_val = g_n+1+find_manhatten_distance(rightlist)
                queue.append([new_heuristics_val,rightlist, lst1,g_n+1,h])
            if (y > 0):
                leftlist = leftstate(copy.deepcopy(initialstate), x, y)
                lst2 = copy.deepcopy(lst)
                lst2.append("left")
                h = find_manhatten_distance(leftlist)
                new_heuristics_val = g_n+1+find_manhatten_distance(leftlist)
                queue.append([new_heuristics_val,leftlist,lst2,g_n+1, h])
            if(x>0):
                uplist = upstate(copy.deepcopy(initialstate), x, y)
                lst3 = copy.deepcopy(lst)
                lst3.append("up")
                h = find_manhatten_distance(uplist) 
                new_heuristics_val = g_n+1+find_manhatten_distance(uplist)
                queue.append([new_heuristics_val,uplist,lst3,g_n+1,h])
            if(x<lenoflist-1):
                downlist = downstate(copy.deepcopy(initialstate), x, y)
                lst4 = copy.deepcopy(lst)
                lst4.append("down")
                h = find_manhatten_distance(downlist)
                new_heuristics_val = g_n+1+find_manhatten_distance(downlist)
                queue.append([new_heuristics_val,downlist,lst4,g_n+1,h])

initialstate = getinitialstate()
targetstate = gettarget(len(initialstate))
print("initial state :")
print_state(initialstate)
print("target state")
print_state(targetstate)
lst1 = heuristics_with_manhatten(initialstate,targetstate)
if(lst1[2]==True):
    print("Number of explored node :",lst1[0])
    print("\nDepth of search node(hight) : ",len(lst1[1]))
    print("\npath of target : ", lst1[1])
    print("Taken Time : ",round(lst1[3],2))
else:
    print("Puzzle could not be solved within given time limit.")
    print("Number of explored nodes :",lst1[0])

#puzzle solved for heuristic value with number of misplaced tiles f(n) = g(n) + h(n)
#h(n) = number of misplaced tiles
def heuristics_with_misplaced(initialstate,targetstate):
    timeLimit=40
    startTime=time.time()
    visited = {}
    queue = []
    heuristics_val = find_number_of_misplaced_tiles(initialstate)
    #queue.append(g(n)+h(n), initialstate, pathlist, g(n),)
    queue.append([0+heuristics_val,initialstate,[],0])
    lenoflist = len(initialstate)
    i =0
    stepcount = 0
    while(len(queue)!=0):
        hq.heapify(queue)
        new_initialstate1 = queue.pop(0)
        initialstate = new_initialstate1[1]
        heuristic_value = new_initialstate1[0]
        lst = copy.deepcopy(new_initialstate1[2])
        g_n = new_initialstate1[3] 
        if(compare_initial_target(initialstate, targetstate)):
            return [stepcount, lst, True,time.time()-startTime]
        if(time.time()-startTime>timeLimit):
            return [stepcount, lst , False,time.time()-startTime]
        k = tuple(map(tuple,initialstate))
        if k not in visited.keys():
            visited.update({k: 1})
            #print(visited)
            stepcount = stepcount + 1
            x, y = find_position_of_blank(initialstate)
            if(x<lenoflist-1):
                downlist = downstate(copy.deepcopy(initialstate), x, y)
                lst4 = copy.deepcopy(lst)
                lst4.append("down")
                new_heuristics_val = g_n+1+find_number_of_misplaced_tiles(downlist)
                queue.append([new_heuristics_val,downlist,lst4,g_n+1])
            if(x>0):
                uplist = upstate(copy.deepcopy(initialstate), x, y)
                lst3 = copy.deepcopy(lst)
                lst3.append("up")
                new_heuristics_val = g_n+1+find_number_of_misplaced_tiles(uplist)
                queue.append([new_heuristics_val,uplist,lst3,g_n+1])
            if (y > 0):
                leftlist = leftstate(copy.deepcopy(initialstate), x, y)
                lst1 = copy.deepcopy(lst)
                lst1.append("left")
                new_heuristics_val = g_n+1+find_number_of_misplaced_tiles(leftlist)
                queue.append([new_heuristics_val,leftlist,lst1,g_n+1])
            if(y<lenoflist-1):
                rightlist = rightstate(copy.deepcopy(initialstate), x, y)
                lst2 = copy.deepcopy(lst)
                lst2.append("right")
                new_heuristics_val = g_n+1+find_number_of_misplaced_tiles(rightlist)
                queue.append([new_heuristics_val,rightlist, lst2,g_n+1])
            

initialstate = getinitialstate()
targetstate = gettarget(len(initialstate))
print("initial state :")
print_state(initialstate)
print("target state")
print_state(targetstate)
lst1 = heuristics_with_misplaced(initialstate,targetstate)
if(lst1[2]==True):
    print("Number of explored node :",lst1[0])
    print("\nDepth of search node(hight) : ",len(lst1[1]))
    print("\npath of target : ", lst1[1])
    print("Taken Time : ",round(lst1[3],2))
else:
    print("Puzzle could not be solved within given time limit.")
    print("Number of explored nodes :",lst1[0])

#puzzle solved for heuristic value with euclidean distance f(n) = g(n) + h(n)
#h(n) = euclidean distance
def heuristics_with_euclidean(initialstate,targetstate):
    timeLimit=40
    startTime=time.time()
    visited = {}
    queue = []
    heuristics_val = find_euclidean(initialstate)
    #queue.append(g(n)+h(n), initialstate, pathlist, g(n),)
    queue.append([0+heuristics_val,initialstate,[],0])
    lenoflist = len(initialstate)
    stepcount = 0
    while(len(queue)!=0):
        hq.heapify(queue)
        new_initialstate1 = queue.pop(0)
        initialstate = new_initialstate1[1]
        lst = copy.deepcopy(new_initialstate1[2])
        g_n = new_initialstate1[3] 
        # print(new_initialstate1)
        # print(initialstate,lst)
        if(compare_initial_target(initialstate, targetstate)):
            return [stepcount, lst , True, time.time()-startTime]
        if(time.time()-startTime>timeLimit):
            return [stepcount, lst , False, time.time()-startTime]

        k = tuple(map(tuple,initialstate))
        if k not in visited.keys():
            visited.update({k: 1})
            #print(visited)
            stepcount = stepcount + 1
            x, y = find_position_of_blank(initialstate)
            if(x<lenoflist-1):
                downlist = downstate(copy.deepcopy(initialstate), x, y)
                lst1 = copy.deepcopy(lst)
                lst1.append("down")
                new_heuristics_val = g_n+1+find_euclidean(downlist)
                queue.append([new_heuristics_val,downlist,lst1,g_n+1])
            if(x>0):
                uplist = upstate(copy.deepcopy(initialstate), x, y)
                lst2 = copy.deepcopy(lst)
                lst2.append("up")
                new_heuristics_val = g_n+1+find_euclidean(uplist)
                queue.append([new_heuristics_val,uplist,lst2,g_n+1])
            if (y > 0):
                leftlist = leftstate(copy.deepcopy(initialstate), x, y)
                lst3 = copy.deepcopy(lst)
                lst3.append("left")
                new_heuristics_val = g_n+1+find_euclidean(leftlist)
                queue.append([new_heuristics_val,leftlist,lst3,g_n+1])
            
            if(y<lenoflist-1):
                rightlist = rightstate(copy.deepcopy(initialstate), x, y)
                lst4 = copy.deepcopy(lst)
                lst4.append("right")
                new_heuristics_val = g_n+1+find_euclidean(rightlist)
                queue.append([new_heuristics_val,rightlist, lst4,g_n+1])
            

initialstate = getinitialstate()
targetstate = gettarget(len(initialstate))
print("initial state :")
print_state(initialstate)
print("target state")
print_state(targetstate)
lst1 = heuristics_with_euclidean(initialstate,targetstate)
if(lst1[2]==True):
    print("Number of explored node :",lst1[0])
    print("\nDepth of search node(hight) : ",len(lst1[1]))
    print("\npath of target : ", lst1[1])
    print("Taken Time : ",round(lst1[3],2))
else:
    print("Puzzle could not be solved within given time limit.")
    print("Number of explored nodes :",lst1[0])

if __name__ == '__main__':
    initialstate = getinitialstate()
    targetstate = gettarget(len(initialstate))
    print("initial state :")
    print_state(initialstate)
    print("target state")
    print_state(targetstate)
    
    print("\nheuristics_with_zero : \n")
    lst1 = heuristics_with_zero(initialstate,targetstate)
    if(lst1[2]==True):
      print("Number of explored node :",lst1[0])
      print("Depth of search node(hight) : ",len(lst1[1]))
      print("path of target : ", lst1[1])
      print("Taken Time : ",round(lst1[3],2))
    else:
      print("Puzzle could not be solved within given time limit.")
      print("Number of explored nodes :",lst1[0])
    
    print("\nheuristics_with_manhatten : \n")
    lst1 = heuristics_with_manhatten(initialstate,targetstate)
    if(lst1[2]==True):
      print("Number of explored node :",lst1[0])
      print("Depth of search node(hight) : ",len(lst1[1]))
      print("path of target : ", lst1[1])
      print("Taken Time : ",round(lst1[3],2))
    else:
      print("Puzzle could not be solved within given time limit.")
      print("Number of explored nodes :",lst1[0])

    print("\nheuristics_with_misplaced : \n")
    lst1 = heuristics_with_misplaced(initialstate,targetstate)
    if(lst1[2]==True):
      print("Number of explored node :",lst1[0])
      print("Depth of search node(hight) : ",len(lst1[1]))
      print("path of target : ", lst1[1])
      print("Taken Time : ",round(lst1[3],2))
    else:
      print("Puzzle could not be solved within given time limit.")
      print("Number of explored nodes :",lst1[0])

    print("\nheuristics_with_euclidean : \n")
    lst1 = heuristics_with_euclidean(initialstate,targetstate)
    if(lst1[2]==True):
      print("Number of explored node :",lst1[0])
      print("Depth of search node(hight) : ",len(lst1[1]))
      print("path of target : ", lst1[1])
      print("Taken Time : ",round(lst1[3],2))
    else:
      print("Puzzle could not be solved within given time limit.")
      print("Number of explored nodes :",lst1[0])